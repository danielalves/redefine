//
//  ALDRedefinition.m
//  Redefine
//
//  Created by Daniel L. Alves on 14/4/14.
//  Copyright (c) 2014 Daniel L. Alves. All rights reserved.
//

#import "ALDRedefinition.h"

// objc
#import <objc/runtime.h>
#import <objc/message.h>

#pragma mark - Typedefs

typedef id(^RedefinitionImplementationBlock)(id object, SEL selector, ...);

#pragma mark - Helper Types

typedef NS_ENUM( uint8_t, SelectorType )
{
    CLASS_SELECTOR,
    CLASS_INSTANCES_SELECTOR,
    SINGLE_INSTANCE_SELECTOR
};

@interface AutoGeneratedClassData : NSObject

@property( nonatomic, readwrite )Class originalClass;
@property( nonatomic, readwrite )Class autoGeneratedClass;
@property( nonatomic, readwrite )IMP redefinedCopyWithZoneImplementation;

@end

@implementation AutoGeneratedClassData

-( void )dealloc
{
    if( _redefinedCopyWithZoneImplementation )
    {
        imp_removeBlock( _redefinedCopyWithZoneImplementation );
        _redefinedCopyWithZoneImplementation = nil;
    }
}

@end

#pragma mark - ALDRedefinition Class Extension

@interface ALDRedefinition()
{
    IMP redefinedImplementation;
    IMP originalImplementation;
    
    Class targetInstanceOriginalClass;
    Class targetInstanceAutoGeneratedClass;
    IMP targetInstanceRedefinedCopyWithZoneImplementation;
}

@property( nonatomic, readonly )Class targetClass;
@property( nonatomic, readonly )SEL targetSelector;
@property( nonatomic, readonly )SelectorType targetSelectorType;
@property( nonatomic, readonly, weak )NSObject *targetInstance;

@property( nonatomic, readwrite )BOOL usingRedefinition;

@end

#pragma mark - ALDRedefinition Implementation

@implementation ALDRedefinition

#pragma mark - Ctors & Dtor

+( instancetype )redefineClass:( Class )aClass selector:( SEL )selector withImplementation:( id )newImplementationBlock
{
    return [[ALDRedefinition alloc] initWithClass: aClass
<<<<<<< Updated upstream
                                       selector: selector
                              newImplementation: newImplementationBlock
                                isClassSelector: YES];
=======
                                         selector: selector
                                           ofType: CLASS_SELECTOR
                                         instance: nil
                                newImplementation: newImplementationBlock];
>>>>>>> Stashed changes
}

+( instancetype )redefineClassInstances:( Class )aClass selector:( SEL )selector withImplementation:( id )newImplementationBlock
{
    return [[ALDRedefinition alloc] initWithClass: aClass
<<<<<<< Updated upstream
                                       selector: selector
                              newImplementation: newImplementationBlock
                                isClassSelector: NO];
=======
                                         selector: selector
                                           ofType: CLASS_INSTANCES_SELECTOR
                                         instance: nil
                                newImplementation: newImplementationBlock];
}

+( instancetype )redefineSingleInstance:( NSObject * )instance selector:( SEL )selector withImplementation:( id )newImplementationBlock
{
    return [[ALDRedefinition alloc] initWithClass: instance.class
                                         selector: selector
                                           ofType: SINGLE_INSTANCE_SELECTOR
                                         instance: instance
                                newImplementation: newImplementationBlock];
>>>>>>> Stashed changes
}

-( instancetype )initWithClass:( Class )aClass
                      selector:( SEL )selector
<<<<<<< Updated upstream
             newImplementation:( id )newImplementationBlock
               isClassSelector:( BOOL )isClassSelector
{
    if( !aClass || !selector || !newImplementationBlock )
=======
                        ofType:( SelectorType )selectorType
                      instance:( NSObject * )instance
             newImplementation:( id )newImplementationBlock
{
    if( !aClass || !selector || !newImplementationBlock || ( !instance && selectorType == SINGLE_INSTANCE_SELECTOR ))
>>>>>>> Stashed changes
        [NSException raise: NSInvalidArgumentException
                    format: @"All parameters must not be nil"];
    
    self = [super init];
    if( self )
    {
        _targetSelector = selector;
        _targetSelectorType = selectorType;
        _targetInstance = instance;
        
        if( selectorType == CLASS_SELECTOR )
        {
<<<<<<< Updated upstream
            _targetClass = objc_getMetaClass( class_getName( aClass ));
=======
            _targetClass = objc_getMetaClass(class_getName( aClass ));
>>>>>>> Stashed changes
            
            if( !class_getClassMethod( _targetClass, selector ))
                [NSException raise: NSInvalidArgumentException
                            format: @"%s does not respond to %s", class_getName( _targetClass ), sel_getName( selector )];
        }
        else
        {
            if( !class_getInstanceMethod( aClass, selector ))
                [NSException raise: NSInvalidArgumentException
<<<<<<< Updated upstream
                            format: @"%s instances do not respond to %s", class_getName( _targetClass ), sel_getName( selector )];
=======
                            format: @"%s instances do not respond to %s", class_getName( aClass ), sel_getName( selector )];

            if( _targetSelectorType == SINGLE_INSTANCE_SELECTOR )
            {
                targetInstanceAutoGeneratedClass = [ALDRedefinition generateNewClassForInstance: _targetInstance
                                                                  originalNonAutoGeneratedClass: &targetInstanceOriginalClass];

                object_setClass( _targetInstance, targetInstanceAutoGeneratedClass );

                _targetClass = targetInstanceAutoGeneratedClass;
            }
            else
            {
                _targetClass = aClass;
            }
>>>>>>> Stashed changes
        }
        
        redefinedImplementation = imp_implementationWithBlock( newImplementationBlock );
        
        [self startUsingRedefinition];
    }
    return self;
}

-( void )dealloc
{
    [self stopUsingRedefinition];
    
    if( redefinedImplementation )
    {
        imp_removeBlock( redefinedImplementation );
        redefinedImplementation = nil;
    }
    
    if( targetInstanceAutoGeneratedClass )
    {
        // TODO : Do not call this function if instances of the class or any subclass exist !!!
        // TODO :
        //
        // 1 - Check if there is still one redefinition with the same target instance
        //    1.1 - If yes : do nothing
        //    1.2 - If no : set the original class back to all instances of targetInstanceAutoGeneratedClass
        //          and then call objc_disposeClassPair
        
        if( !_targetInstance )
        {
            objc_disposeClassPair( targetInstanceAutoGeneratedClass );
            targetInstanceAutoGeneratedClass = Nil;
        }
    }
}

#pragma mark - Redefinition Object Management

-( void )startUsingRedefinition
{
    @synchronized( self.class )
    {
        if( !_usingRedefinition )
        {
            [ALDRedefinition stopPreviousRedefinitionWithSameTargetAndRegisterRedefinition: self];

            originalImplementation = class_replaceMethod( _targetClass, _targetSelector, redefinedImplementation, NULL );

            // class_replaceMethod does not return the original implementation of a selector when we generate
            // a new class. So we need to retrieve it from the original class
            if( !originalImplementation && _targetSelectorType == SINGLE_INSTANCE_SELECTOR )
                originalImplementation = method_getImplementation( class_getInstanceMethod( targetInstanceOriginalClass, _targetSelector ));
            
            NSAssert( originalImplementation != nil, @"Original implementation must never be nil" );

            self.usingRedefinition = YES;
        }
    }
}

-( void )stopUsingRedefinition
{
    @synchronized( self.class )
    {
        if( _usingRedefinition )
        {
            NSAssert( originalImplementation != nil, @"Original implementation must never be nil" );
            
            class_replaceMethod( _targetClass, _targetSelector, originalImplementation, NULL );
            self.usingRedefinition = NO;
        }
    }
}

#pragma mark - Global Redefinition Management

+( void )stopPreviousRedefinitionWithSameTargetAndRegisterRedefinition:( ALDRedefinition * )redefinition
{
    @synchronized( self )
    {
        ALDRedefinition *sameTargetRedefinition = [self currentRedefinitionForSelector: redefinition.targetSelector
                                                                                  type: redefinition.targetSelectorType
                                                                               ofClass: redefinition.targetClass];
        if( sameTargetRedefinition )
            [sameTargetRedefinition stopUsingRedefinition];
        
        NSString *key = [self keyFromSelector: redefinition.targetSelector
                                         type: redefinition.targetSelectorType
                                      ofClass: redefinition.targetClass];
        
        [[self currentRedefinitions] setObject: redefinition forKey: key];
    }
}

+( ALDRedefinition * )currentRedefinitionForSelector:( SEL )selector type:( SelectorType )selectorType ofClass:( Class )aClass
{
    @synchronized( self )
    {
        NSString *key = [self keyFromSelector: selector type: selectorType ofClass: aClass];
        return [[self currentRedefinitions] objectForKey: key];
    }
}

+( NSMapTable * )currentRedefinitions
{
    @synchronized( self )
    {
        static NSMapTable *currentRedefinitions = nil;
    
        // If we do not hold weak references to the redefinitions, they'll never be dealocated. Hence we would
        // never bring the original implementations back
        if( !currentRedefinitions )
            currentRedefinitions = [NSMapTable strongToWeakObjectsMapTable];

        return currentRedefinitions;
    }
}

#pragma mark - Helpers

+( NSString * )keyFromSelector:( SEL )selector type:( SelectorType )selectorType ofClass:( Class )aClass
{
    return [NSString stringWithFormat: @"%s_%s_%s", class_getName( aClass ),
                                       sel_getName( selector ),
                                       selectorType == CLASS_SELECTOR ? "CL" : ( selectorType == CLASS_INSTANCES_SELECTOR ? "AI" : "SI" )];
}

+( NSString * )autoGeneratedClassNameForInstance:( NSObject * )instance
{
    return [NSString stringWithFormat: @"__%s_SnglInst_%x_RedefOf_%s",
                                       class_getName( self.class ),
                                       // Gets the address of the instance
                                       ( unsigned int )instance,
                                       class_getName( instance.class )];
}

+( NSMapTable * )autoGeneratedClasses
{
    @synchronized( self )
    {
        static NSMapTable *autoGeneratedClasses = nil;
        
        // If we do not hold weak references to the redefinitions, they'll never be dealocated. Hence we would
        // never bring the original implementations back
        if( !autoGeneratedClasses )
            autoGeneratedClasses = [NSMapTable mapTableWithKeyOptions: NSMapTableStrongMemory
                                                         valueOptions: NSMapTableStrongMemory];
        
        return autoGeneratedClasses;
    }
}

+( Class )generateNewClassForInstance:( NSObject * )instance originalNonAutoGeneratedClass:( out Class * )originalNonAutoGeneratedClass
{
    @synchronized( self )
    {
        // Maybe this is a copy of or an already redefined object. So let's check if its class is in our table of auto generated
        // classes
        NSString *autoGeneratedClassName = [NSString stringWithUTF8String: class_getName( instance.class )];
        AutoGeneratedClassData *autoGeneratedClassData = [[self autoGeneratedClasses] objectForKey: autoGeneratedClassName];
        if( !autoGeneratedClassData )
        {
            autoGeneratedClassName = [self autoGeneratedClassNameForInstance: instance];
            
            autoGeneratedClassData = [AutoGeneratedClassData new];
            autoGeneratedClassData.originalClass = instance.class;
            
            autoGeneratedClassData.autoGeneratedClass = objc_allocateClassPair( instance.class, [autoGeneratedClassName UTF8String], 0 );

            // TODO : Set the destructor to notify the object deallocation !!!!!!
            // ...
            
            // TODO : Override allocWithZone and copyWithZone so we can track objects of the new generated class from outside
            // ...
            
            Class originalClass = autoGeneratedClassData.originalClass;
            Class autoGeneratedClass = autoGeneratedClassData.originalClass;
            Class superClass = instance.superclass;
            RedefinitionImplementationBlock redefinedCopyWithZone = ^(id object, SEL selector, ...) {
                
                NSLog( @"HAHAHAHAHAHA" );
                
                struct objc_super mySuper;
                mySuper.receiver = object;
                mySuper.super_class = superClass;
                
                NSObject *copy = objc_msgSendSuper( &mySuper, selector );
                if( copy != object && copy.class == originalClass )
                    object_setClass( copy, autoGeneratedClass );

                return copy;
            };
            autoGeneratedClassData.redefinedCopyWithZoneImplementation = imp_implementationWithBlock( redefinedCopyWithZone );
            class_replaceMethod( autoGeneratedClass, @selector( copyWithZone: ), autoGeneratedClassData.redefinedCopyWithZoneImplementation, NULL );

            objc_registerClassPair( autoGeneratedClassData.autoGeneratedClass );
            
            [[self autoGeneratedClasses] setObject: autoGeneratedClassData forKey: autoGeneratedClassName];
        }
        
        if( originalNonAutoGeneratedClass )
            *originalNonAutoGeneratedClass = autoGeneratedClassData.originalClass;
        
        return autoGeneratedClassData.autoGeneratedClass;
    }
}

@end
